var http = require('http');
var process = require('process');
var fs = require('fs');
var path = require('path');
var util = require('util');
var os = require('os');
var crypto = require('crypto');

exports.md5 = function md5(str){
	return crypto.createHash('md5').update(str).digest('hex');
}

exports.hello = function hello(){
    console.log('hello by zengming!');
}

//实现类似于PHP rand()，生成的随机数包含min和max
exports.rand = function rand(min, max) {
    return Math.random()*(max-min+1) + min | 0;
}
/**
 * 获取html网页
 * @param url
 * @param callback(err,content)
 *                 content正常返回html，出错返回url
 */
exports.getHtml = function getHtml(url, callback) {
    http.get(url, function (res) {
        var html = '';
        res.setEncoding("utf8");
        res.on('data', function (chunk) {
            html += chunk;
        })
        res.on('end', function () {
            callback(null, html);
        })
    }).on('error',function (e) {
        callback(e, url);
    });
}


/**
 * 下载文件到指定路径
 * @param url
 * @param saveTo  保存路径
 * @param callback (e,p1,p2) 正常情况下只返回p1为文件长度,出错时p1,p2为传递的url和saveTo
 */
exports.download = function download(url, saveTo, callback) {
    var req = http.request(url,function (res) {  //直接用http.get会在网络不好的情况下产生阻塞，不知道超时时间设置的多少
        var len = parseInt(res.headers['content-length']);
        var ws = fs.createWriteStream(saveTo);
        ws.on('finish',function () { //最好在管道对接前执行
            if(len === this.bytesWritten){
                callback(null,len);
            }
        })
        res.pipe(ws);
    });
    req.on('error',function (e) {
        callback(e, url, saveTo);
    });
    req.setTimeout(10000,function () {
        req.abort(); //发生超时居然不是中断，而是在重试
        callback("超时", url, saveTo);
    })
    req.end();
}


/**
 * 和原版的用法相同，但是不会返回NaN
 */
exports.parseInt = function(string, radix){
    var v = parseInt(string, radix);
    return isNaN(v) ? 0 : v;
}
/**
 * 和原版的用法相同，但是不会返回NaN
 */
exports.parseFloat = function(string){
    var v = parseFloat(string);
    return isNaN(v) ? 0 : v;
}

exports.base64_encode = function base64_encode(str) {
    return new Buffer(str).toString('base64');
}
exports.base64_decode = function base64_decode(str){
    return new Buffer(str,'base64').toString();
}

exports.getLocalIP = function getLocalIP() {
    var ifs = os.networkInterfaces();

    for(var i in ifs){
        if(i === 'lo') continue;
        var if0 = ifs[i];
        for(var i=0; i<if0.length; i++){
            var a = if0[i];
            if(a.family === 'IPv4'){
                return a.address;
            }
        }
        break;
    }
}

exports.log = console.log;